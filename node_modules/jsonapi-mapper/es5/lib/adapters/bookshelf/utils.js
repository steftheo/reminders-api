var _ = require('lodash');
var links = require('./links');
/**
 * Builds the relationship transform schema.
 * @param baseUrl
 * @param modelType
 * @param relatedType
 * @param relatedKeys
 * @param included
 * @returns serializer.ISerializerOptions
 */
function buildRelation(baseUrl, modelType, relatedType, relatedKeys, included) {
    return {
        ref: 'id',
        attributes: relatedKeys,
        relationshipLinks: links.buildRelationship(baseUrl, modelType, relatedType),
        includedLinks: links.buildSelf(baseUrl, modelType),
        included: included
    };
}
exports.buildRelation = buildRelation;
/**
 * Retrieves data's attributes list
 * omiting _id and _type attributes
 * @param data
 * @returns {string[]}
 */
function getDataAttributesList(data) {
    return _.keys(getDataAttributes(data)).filter(function (name) {
        return name !== 'id' &&
            !_.endsWith(name, '_id') &&
            !_.endsWith(name, '_type');
    });
}
exports.getDataAttributesList = getDataAttributesList;
/**
 * Retrieves data's attributes
 * @param data
 * @returns {any}
 * @private
 */
function getDataAttributes(data) {
    // Model Case
    if (isModel(data)) {
        var m = data;
        return m.attributes;
    }
    else if (isCollection(data)) {
        var c = data;
        return c.models[0] && c.models[0].attributes;
    }
}
exports.getDataAttributes = getDataAttributes;
/**
 * Determine whether a Bookshelf object is a Model.
 * @param data
 * @returns {boolean}
 */
function isModel(data) {
    // Is-not-a-Duck-typing
    return data.models === undefined;
}
exports.isModel = isModel;
/**
 * Determine whether a Bookshelf object is a Collection.
 * @param data
 * @returns {boolean}
 */
function isCollection(data) {
    // Duck-typing
    return data.models !== undefined;
}
exports.isCollection = isCollection;
//# sourceMappingURL=utils.js.map